/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.81.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKeyCreateDto
 */
export interface APIKeyCreateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface APIKeyCreateResponseDto
 */
export interface APIKeyCreateResponseDto {
    /**
     * 
     * @type {APIKeyResponseDto}
     * @memberof APIKeyCreateResponseDto
     */
    'apiKey': APIKeyResponseDto;
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateResponseDto
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface APIKeyResponseDto
 */
export interface APIKeyResponseDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface APIKeyUpdateDto
 */
export interface APIKeyUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyUpdateDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AddUsersDto
 */
export interface AddUsersDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersDto
     */
    'sharedUserIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminSignupResponseDto
 */
export interface AdminSignupResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface AlbumCountResponseDto
 */
export interface AlbumCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'notShared': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'owned': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'shared': number;
}
/**
 * 
 * @export
 * @interface AlbumResponseDto
 */
export interface AlbumResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumName': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumThumbnailAssetId': string | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumResponseDto
     */
    'assetCount': number;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof AlbumResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'hasSharedLink': boolean;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'lastModifiedAssetTimestamp'?: string;
    /**
     * 
     * @type {UserResponseDto}
     * @memberof AlbumResponseDto
     */
    'owner': UserResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'shared': boolean;
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof AlbumResponseDto
     */
    'sharedUsers': Array<UserResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface AllJobStatusResponseDto
 */
export interface AllJobStatusResponseDto {
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'backgroundTask': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'clipEncoding': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'library': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'metadataExtraction': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'migration': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'objectTagging': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'recognizeFaces': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'search': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'sidecar': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'storageTemplateMigration': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'thumbnailGeneration': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'videoConversion': JobStatusDto;
}
/**
 * 
 * @export
 * @interface AssetBulkDeleteDto
 */
export interface AssetBulkDeleteDto {
    /**
     * 
     * @type {boolean}
     * @memberof AssetBulkDeleteDto
     */
    'force'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetBulkDeleteDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface AssetBulkUpdateDto
 */
export interface AssetBulkUpdateDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetBulkUpdateDto
     */
    'ids': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AssetBulkUpdateDto
     */
    'isArchived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetBulkUpdateDto
     */
    'isFavorite'?: boolean;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckDto
 */
export interface AssetBulkUploadCheckDto {
    /**
     * 
     * @type {Array<AssetBulkUploadCheckItem>}
     * @memberof AssetBulkUploadCheckDto
     */
    'assets': Array<AssetBulkUploadCheckItem>;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckItem
 */
export interface AssetBulkUploadCheckItem {
    /**
     * base64 or hex encoded sha1 hash
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'checksum': string;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckResponseDto
 */
export interface AssetBulkUploadCheckResponseDto {
    /**
     * 
     * @type {Array<AssetBulkUploadCheckResult>}
     * @memberof AssetBulkUploadCheckResponseDto
     */
    'results': Array<AssetBulkUploadCheckResult>;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckResult
 */
export interface AssetBulkUploadCheckResult {
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'action': AssetBulkUploadCheckResultActionEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'assetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'reason'?: AssetBulkUploadCheckResultReasonEnum;
}

export const AssetBulkUploadCheckResultActionEnum = {
    Accept: 'accept',
    Reject: 'reject'
} as const;

export type AssetBulkUploadCheckResultActionEnum = typeof AssetBulkUploadCheckResultActionEnum[keyof typeof AssetBulkUploadCheckResultActionEnum];
export const AssetBulkUploadCheckResultReasonEnum = {
    Duplicate: 'duplicate',
    UnsupportedFormat: 'unsupported-format'
} as const;

export type AssetBulkUploadCheckResultReasonEnum = typeof AssetBulkUploadCheckResultReasonEnum[keyof typeof AssetBulkUploadCheckResultReasonEnum];

/**
 * 
 * @export
 * @interface AssetFileUploadResponseDto
 */
export interface AssetFileUploadResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof AssetFileUploadResponseDto
     */
    'duplicate': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetFileUploadResponseDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AssetIdsDto
 */
export interface AssetIdsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetIdsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AssetIdsResponseDto
 */
export interface AssetIdsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AssetIdsResponseDto
     */
    'assetId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetIdsResponseDto
     */
    'error'?: AssetIdsResponseDtoErrorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AssetIdsResponseDto
     */
    'success': boolean;
}

export const AssetIdsResponseDtoErrorEnum = {
    Duplicate: 'duplicate',
    NoPermission: 'no_permission',
    NotFound: 'not_found'
} as const;

export type AssetIdsResponseDtoErrorEnum = typeof AssetIdsResponseDtoErrorEnum[keyof typeof AssetIdsResponseDtoErrorEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const AssetJobName = {
    RegenerateThumbnail: 'regenerate-thumbnail',
    RefreshMetadata: 'refresh-metadata',
    TranscodeVideo: 'transcode-video'
} as const;

export type AssetJobName = typeof AssetJobName[keyof typeof AssetJobName];


/**
 * 
 * @export
 * @interface AssetJobsDto
 */
export interface AssetJobsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetJobsDto
     */
    'assetIds': Array<string>;
    /**
     * 
     * @type {AssetJobName}
     * @memberof AssetJobsDto
     */
    'name': AssetJobName;
}
/**
 * 
 * @export
 * @interface AssetResponseDto
 */
export interface AssetResponseDto {
    /**
     * base64 encoded sha1 hash
     * @type {string}
     * @memberof AssetResponseDto
     */
    'checksum': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'duration': string;
    /**
     * 
     * @type {ExifResponseDto}
     * @memberof AssetResponseDto
     */
    'exifInfo'?: ExifResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileCreatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileModifiedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isArchived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isExternal': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isFavorite': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isOffline': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isReadOnly': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isTrashed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'libraryId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'livePhotoVideoId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'localDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalFileName': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalPath': string;
    /**
     * 
     * @type {UserResponseDto}
     * @memberof AssetResponseDto
     */
    'owner'?: UserResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {Array<PersonResponseDto>}
     * @memberof AssetResponseDto
     */
    'people'?: Array<PersonResponseDto>;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'resized': boolean;
    /**
     * 
     * @type {SmartInfoResponseDto}
     * @memberof AssetResponseDto
     */
    'smartInfo'?: SmartInfoResponseDto;
    /**
     * 
     * @type {Array<TagResponseDto>}
     * @memberof AssetResponseDto
     */
    'tags'?: Array<TagResponseDto>;
    /**
     * base64 encoded thumbhash
     * @type {string}
     * @memberof AssetResponseDto
     */
    'thumbhash': string | null;
    /**
     * 
     * @type {AssetTypeEnum}
     * @memberof AssetResponseDto
     */
    'type': AssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface AssetStatsResponseDto
 */
export interface AssetStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'images': number;
    /**
     * 
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'videos': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
} as const;

export type AssetTypeEnum = typeof AssetTypeEnum[keyof typeof AssetTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const AudioCodec = {
    Mp3: 'mp3',
    Aac: 'aac',
    Libopus: 'libopus'
} as const;

export type AudioCodec = typeof AudioCodec[keyof typeof AudioCodec];


/**
 * 
 * @export
 * @interface AuditDeletesResponseDto
 */
export interface AuditDeletesResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AuditDeletesResponseDto
     */
    'ids': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AuditDeletesResponseDto
     */
    'needsFullSync': boolean;
}
/**
 * 
 * @export
 * @interface AuthDeviceResponseDto
 */
export interface AuthDeviceResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthDeviceResponseDto
     */
    'current': boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceOS': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceType': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BulkIdResponseDto
 */
export interface BulkIdResponseDto {
    /**
     * 
     * @type {string}
     * @memberof BulkIdResponseDto
     */
    'error'?: BulkIdResponseDtoErrorEnum;
    /**
     * 
     * @type {string}
     * @memberof BulkIdResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIdResponseDto
     */
    'success': boolean;
}

export const BulkIdResponseDtoErrorEnum = {
    Duplicate: 'duplicate',
    NoPermission: 'no_permission',
    NotFound: 'not_found',
    Unknown: 'unknown'
} as const;

export type BulkIdResponseDtoErrorEnum = typeof BulkIdResponseDtoErrorEnum[keyof typeof BulkIdResponseDtoErrorEnum];

/**
 * 
 * @export
 * @interface BulkIdsDto
 */
export interface BulkIdsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkIdsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CLIPConfig
 */
export interface CLIPConfig {
    /**
     * 
     * @type {boolean}
     * @memberof CLIPConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {CLIPMode}
     * @memberof CLIPConfig
     */
    'mode'?: CLIPMode;
    /**
     * 
     * @type {string}
     * @memberof CLIPConfig
     */
    'modelName': string;
    /**
     * 
     * @type {ModelType}
     * @memberof CLIPConfig
     */
    'modelType'?: ModelType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CLIPMode = {
    Vision: 'vision',
    Text: 'text'
} as const;

export type CLIPMode = typeof CLIPMode[keyof typeof CLIPMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const CQMode = {
    Auto: 'auto',
    Cqp: 'cqp',
    Icq: 'icq'
} as const;

export type CQMode = typeof CQMode[keyof typeof CQMode];


/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetDto
 */
export interface CheckDuplicateAssetDto {
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetResponseDto
 */
export interface CheckDuplicateAssetResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'isExist': boolean;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsDto
 */
export interface CheckExistingAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsDto
     */
    'deviceAssetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CheckExistingAssetsDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsResponseDto
 */
export interface CheckExistingAssetsResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsResponseDto
     */
    'existingIds': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CitiesFile = {
    Cities15000: 'cities15000',
    Cities5000: 'cities5000',
    Cities1000: 'cities1000',
    Cities500: 'cities500'
} as const;

export type CitiesFile = typeof CitiesFile[keyof typeof CitiesFile];


/**
 * 
 * @export
 * @interface ClassificationConfig
 */
export interface ClassificationConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ClassificationConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClassificationConfig
     */
    'minScore': number;
    /**
     * 
     * @type {string}
     * @memberof ClassificationConfig
     */
    'modelName': string;
    /**
     * 
     * @type {ModelType}
     * @memberof ClassificationConfig
     */
    'modelType'?: ModelType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Colorspace = {
    Srgb: 'srgb',
    P3: 'p3'
} as const;

export type Colorspace = typeof Colorspace[keyof typeof Colorspace];


/**
 * 
 * @export
 * @interface CreateAlbumDto
 */
export interface CreateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'albumName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'assetIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'sharedWithUserIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateLibraryDto
 */
export interface CreateLibraryDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateLibraryDto
     */
    'exclusionPatterns'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateLibraryDto
     */
    'importPaths'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLibraryDto
     */
    'isVisible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateLibraryDto
     */
    'name'?: string;
    /**
     * 
     * @type {LibraryType}
     * @memberof CreateLibraryDto
     */
    'type': LibraryType;
}
/**
 * 
 * @export
 * @interface CreateProfileImageResponseDto
 */
export interface CreateProfileImageResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof CreateTagDto
     */
    'type': TagTypeEnum;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'externalPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastName': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserDto
     */
    'memoriesEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'storageLabel'?: string | null;
}
/**
 * 
 * @export
 * @interface CuratedLocationsResponseDto
 */
export interface CuratedLocationsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'resizePath': string;
}
/**
 * 
 * @export
 * @interface CuratedObjectsResponseDto
 */
export interface CuratedObjectsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'resizePath': string;
}
/**
 * 
 * @export
 * @interface DownloadArchiveInfo
 */
export interface DownloadArchiveInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof DownloadArchiveInfo
     */
    'assetIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DownloadArchiveInfo
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface DownloadInfoDto
 */
export interface DownloadInfoDto {
    /**
     * 
     * @type {string}
     * @memberof DownloadInfoDto
     */
    'albumId'?: string;
    /**
     * 
     * @type {number}
     * @memberof DownloadInfoDto
     */
    'archiveSize'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DownloadInfoDto
     */
    'assetIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DownloadInfoDto
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface DownloadResponseDto
 */
export interface DownloadResponseDto {
    /**
     * 
     * @type {Array<DownloadArchiveInfo>}
     * @memberof DownloadResponseDto
     */
    'archives': Array<DownloadArchiveInfo>;
    /**
     * 
     * @type {number}
     * @memberof DownloadResponseDto
     */
    'totalSize': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityType = {
    Asset: 'ASSET',
    Album: 'ALBUM'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * @export
 * @interface ExifResponseDto
 */
export interface ExifResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'dateTimeOriginal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageHeight'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageWidth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'exposureTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fileSizeInByte'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'focalLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'iso'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'lensModel'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'make'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'modifyDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'orientation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'projectionType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'timeZone'?: string | null;
}
/**
 * 
 * @export
 * @interface ImportAssetDto
 */
export interface ImportAssetDto {
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'assetPath': string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'fileCreatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'fileModifiedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isArchived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isExternal'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isFavorite': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isOffline'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isReadOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportAssetDto
     */
    'isVisible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'libraryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportAssetDto
     */
    'sidecarPath'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobCommand = {
    Start: 'start',
    Pause: 'pause',
    Resume: 'resume',
    Empty: 'empty'
} as const;

export type JobCommand = typeof JobCommand[keyof typeof JobCommand];


/**
 * 
 * @export
 * @interface JobCommandDto
 */
export interface JobCommandDto {
    /**
     * 
     * @type {JobCommand}
     * @memberof JobCommandDto
     */
    'command': JobCommand;
    /**
     * 
     * @type {boolean}
     * @memberof JobCommandDto
     */
    'force': boolean;
}
/**
 * 
 * @export
 * @interface JobCountsDto
 */
export interface JobCountsDto {
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'active': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'completed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'delayed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'failed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'paused': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'waiting': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobName = {
    ThumbnailGeneration: 'thumbnailGeneration',
    MetadataExtraction: 'metadataExtraction',
    VideoConversion: 'videoConversion',
    ObjectTagging: 'objectTagging',
    RecognizeFaces: 'recognizeFaces',
    ClipEncoding: 'clipEncoding',
    BackgroundTask: 'backgroundTask',
    StorageTemplateMigration: 'storageTemplateMigration',
    Migration: 'migration',
    Search: 'search',
    Sidecar: 'sidecar',
    Library: 'library'
} as const;

export type JobName = typeof JobName[keyof typeof JobName];


/**
 * 
 * @export
 * @interface JobSettingsDto
 */
export interface JobSettingsDto {
    /**
     * 
     * @type {number}
     * @memberof JobSettingsDto
     */
    'concurrency': number;
}
/**
 * 
 * @export
 * @interface JobStatusDto
 */
export interface JobStatusDto {
    /**
     * 
     * @type {JobCountsDto}
     * @memberof JobStatusDto
     */
    'jobCounts': JobCountsDto;
    /**
     * 
     * @type {QueueStatusDto}
     * @memberof JobStatusDto
     */
    'queueStatus': QueueStatusDto;
}
/**
 * 
 * @export
 * @interface LibraryResponseDto
 */
export interface LibraryResponseDto {
    /**
     * 
     * @type {number}
     * @memberof LibraryResponseDto
     */
    'assetCount': number;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryResponseDto
     */
    'exclusionPatterns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryResponseDto
     */
    'importPaths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'refreshedAt': string | null;
    /**
     * 
     * @type {LibraryType}
     * @memberof LibraryResponseDto
     */
    'type': LibraryType;
    /**
     * 
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface LibraryStatsResponseDto
 */
export interface LibraryStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'videos': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LibraryType = {
    Upload: 'UPLOAD',
    External: 'EXTERNAL'
} as const;

export type LibraryType = typeof LibraryType[keyof typeof LibraryType];


/**
 * 
 * @export
 * @interface LoginCredentialDto
 */
export interface LoginCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userEmail': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'redirectUri': string;
    /**
     * 
     * @type {boolean}
     * @memberof LogoutResponseDto
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface MapMarkerResponseDto
 */
export interface MapMarkerResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MapMarkerResponseDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lon': number;
}
/**
 * 
 * @export
 * @interface MemoryLaneResponseDto
 */
export interface MemoryLaneResponseDto {
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof MemoryLaneResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof MemoryLaneResponseDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface MergePersonDto
 */
export interface MergePersonDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof MergePersonDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelType = {
    ImageClassification: 'image-classification',
    FacialRecognition: 'facial-recognition',
    Clip: 'clip'
} as const;

export type ModelType = typeof ModelType[keyof typeof ModelType];


/**
 * 
 * @export
 * @interface OAuthAuthorizeResponseDto
 */
export interface OAuthAuthorizeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthAuthorizeResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface OAuthCallbackDto
 */
export interface OAuthCallbackDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthCallbackDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigDto
 */
export interface OAuthConfigDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigResponseDto
 */
export interface OAuthConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'autoLaunch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'buttonText'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'passwordLoginEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PeopleResponseDto
 */
export interface PeopleResponseDto {
    /**
     * 
     * @type {Array<PersonResponseDto>}
     * @memberof PeopleResponseDto
     */
    'people': Array<PersonResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof PeopleResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PeopleResponseDto
     */
    'visible': number;
}
/**
 * 
 * @export
 * @interface PeopleUpdateDto
 */
export interface PeopleUpdateDto {
    /**
     * 
     * @type {Array<PeopleUpdateItem>}
     * @memberof PeopleUpdateDto
     */
    'people': Array<PeopleUpdateItem>;
}
/**
 * 
 * @export
 * @interface PeopleUpdateItem
 */
export interface PeopleUpdateItem {
    /**
     * Person date of birth. Note: the mobile app cannot currently set the birth date to null.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'birthDate'?: string | null;
    /**
     * Asset is used to get the feature face thumbnail.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'featureFaceAssetId'?: string;
    /**
     * Person id.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'id': string;
    /**
     * Person visibility
     * @type {boolean}
     * @memberof PeopleUpdateItem
     */
    'isHidden'?: boolean;
    /**
     * Person name.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PersonResponseDto
 */
export interface PersonResponseDto {
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'birthDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PersonResponseDto
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'thumbnailPath': string;
}
/**
 * 
 * @export
 * @interface PersonUpdateDto
 */
export interface PersonUpdateDto {
    /**
     * Person date of birth. Note: the mobile app cannot currently set the birth date to null.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'birthDate'?: string | null;
    /**
     * Asset is used to get the feature face thumbnail.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'featureFaceAssetId'?: string;
    /**
     * Person visibility
     * @type {boolean}
     * @memberof PersonUpdateDto
     */
    'isHidden'?: boolean;
    /**
     * Person name.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface QueueStatusDto
 */
export interface QueueStatusDto {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isPaused': boolean;
}
/**
 * 
 * @export
 * @interface RecognitionConfig
 */
export interface RecognitionConfig {
    /**
     * 
     * @type {boolean}
     * @memberof RecognitionConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof RecognitionConfig
     */
    'maxDistance': number;
    /**
     * 
     * @type {number}
     * @memberof RecognitionConfig
     */
    'minFaces': number;
    /**
     * 
     * @type {number}
     * @memberof RecognitionConfig
     */
    'minScore': number;
    /**
     * 
     * @type {string}
     * @memberof RecognitionConfig
     */
    'modelName': string;
    /**
     * 
     * @type {ModelType}
     * @memberof RecognitionConfig
     */
    'modelType'?: ModelType;
}
/**
 * 
 * @export
 * @interface ScanLibraryDto
 */
export interface ScanLibraryDto {
    /**
     * 
     * @type {boolean}
     * @memberof ScanLibraryDto
     */
    'refreshAllFiles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScanLibraryDto
     */
    'refreshModifiedFiles'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchAlbumResponseDto
 */
export interface SearchAlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
    /**
     * 
     * @type {Array<AlbumResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'items': Array<AlbumResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface SearchAssetDto
 */
export interface SearchAssetDto {
    /**
     * 
     * @type {string}
     * @memberof SearchAssetDto
     */
    'searchTerm': string;
}
/**
 * 
 * @export
 * @interface SearchAssetResponseDto
 */
export interface SearchAssetResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'items': Array<AssetResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface SearchExploreItem
 */
export interface SearchExploreItem {
    /**
     * 
     * @type {AssetResponseDto}
     * @memberof SearchExploreItem
     */
    'data': AssetResponseDto;
    /**
     * 
     * @type {string}
     * @memberof SearchExploreItem
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SearchExploreResponseDto
 */
export interface SearchExploreResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SearchExploreResponseDto
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<SearchExploreItem>}
     * @memberof SearchExploreResponseDto
     */
    'items': Array<SearchExploreItem>;
}
/**
 * 
 * @export
 * @interface SearchFacetCountResponseDto
 */
export interface SearchFacetCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchFacetCountResponseDto
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof SearchFacetCountResponseDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SearchFacetResponseDto
 */
export interface SearchFacetResponseDto {
    /**
     * 
     * @type {Array<SearchFacetCountResponseDto>}
     * @memberof SearchFacetResponseDto
     */
    'counts': Array<SearchFacetCountResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof SearchFacetResponseDto
     */
    'fieldName': string;
}
/**
 * 
 * @export
 * @interface SearchResponseDto
 */
export interface SearchResponseDto {
    /**
     * 
     * @type {SearchAlbumResponseDto}
     * @memberof SearchResponseDto
     */
    'albums': SearchAlbumResponseDto;
    /**
     * 
     * @type {SearchAssetResponseDto}
     * @memberof SearchResponseDto
     */
    'assets': SearchAssetResponseDto;
}
/**
 * 
 * @export
 * @interface ServerConfigDto
 */
export interface ServerConfigDto {
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfigDto
     */
    'isInitialized': boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfigDto
     */
    'loginPageMessage': string;
    /**
     * 
     * @type {string}
     * @memberof ServerConfigDto
     */
    'mapTileUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ServerConfigDto
     */
    'oauthButtonText': string;
    /**
     * 
     * @type {number}
     * @memberof ServerConfigDto
     */
    'trashDays': number;
}
/**
 * 
 * @export
 * @interface ServerFeaturesDto
 */
export interface ServerFeaturesDto {
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'clipEncode': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'configFile': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'facialRecognition': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'map': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'oauth': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'oauthAutoLaunch': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'passwordLogin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'reverseGeocoding': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'search': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'sidecar': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'tagImage': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'trash': boolean;
}
/**
 * 
 * @export
 * @interface ServerInfoResponseDto
 */
export interface ServerInfoResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailable': string;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailableRaw': number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskSize': string;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskSizeRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUsagePercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskUse': string;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUseRaw': number;
}
/**
 * 
 * @export
 * @interface ServerMediaTypesResponseDto
 */
export interface ServerMediaTypesResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'image': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'sidecar': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'video': Array<string>;
}
/**
 * 
 * @export
 * @interface ServerPingResponse
 */
export interface ServerPingResponse {
    /**
     * 
     * @type {string}
     * @memberof ServerPingResponse
     */
    'res': string;
}
/**
 * 
 * @export
 * @interface ServerStatsResponseDto
 */
export interface ServerStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'usage': number;
    /**
     * 
     * @type {Array<UsageByUserDto>}
     * @memberof ServerStatsResponseDto
     */
    'usageByUser': Array<UsageByUserDto>;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'videos': number;
}
/**
 * 
 * @export
 * @interface ServerVersionResponseDto
 */
export interface ServerVersionResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'major': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'minor': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'patch': number;
}
/**
 * 
 * @export
 * @interface SharedLinkCreateDto
 */
export interface SharedLinkCreateDto {
    /**
     * 
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'albumId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SharedLinkCreateDto
     */
    'assetIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'showExif'?: boolean;
    /**
     * 
     * @type {SharedLinkType}
     * @memberof SharedLinkCreateDto
     */
    'type': SharedLinkType;
}
/**
 * 
 * @export
 * @interface SharedLinkEditDto
 */
export interface SharedLinkEditDto {
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkEditDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkEditDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'showExif'?: boolean;
}
/**
 * 
 * @export
 * @interface SharedLinkResponseDto
 */
export interface SharedLinkResponseDto {
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof SharedLinkResponseDto
     */
    'album'?: AlbumResponseDto;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowDownload': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowUpload': boolean;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SharedLinkResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'key': string;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'showExif': boolean;
    /**
     * 
     * @type {SharedLinkType}
     * @memberof SharedLinkResponseDto
     */
    'type': SharedLinkType;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SharedLinkType = {
    Album: 'ALBUM',
    Individual: 'INDIVIDUAL'
} as const;

export type SharedLinkType = typeof SharedLinkType[keyof typeof SharedLinkType];


/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SmartInfoResponseDto
 */
export interface SmartInfoResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'objects'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'tags'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SystemConfigDto
 */
export interface SystemConfigDto {
    /**
     * 
     * @type {SystemConfigFFmpegDto}
     * @memberof SystemConfigDto
     */
    'ffmpeg': SystemConfigFFmpegDto;
    /**
     * 
     * @type {SystemConfigJobDto}
     * @memberof SystemConfigDto
     */
    'job': SystemConfigJobDto;
    /**
     * 
     * @type {SystemConfigMachineLearningDto}
     * @memberof SystemConfigDto
     */
    'machineLearning': SystemConfigMachineLearningDto;
    /**
     * 
     * @type {SystemConfigMapDto}
     * @memberof SystemConfigDto
     */
    'map': SystemConfigMapDto;
    /**
     * 
     * @type {SystemConfigOAuthDto}
     * @memberof SystemConfigDto
     */
    'oauth': SystemConfigOAuthDto;
    /**
     * 
     * @type {SystemConfigPasswordLoginDto}
     * @memberof SystemConfigDto
     */
    'passwordLogin': SystemConfigPasswordLoginDto;
    /**
     * 
     * @type {SystemConfigReverseGeocodingDto}
     * @memberof SystemConfigDto
     */
    'reverseGeocoding': SystemConfigReverseGeocodingDto;
    /**
     * 
     * @type {SystemConfigStorageTemplateDto}
     * @memberof SystemConfigDto
     */
    'storageTemplate': SystemConfigStorageTemplateDto;
    /**
     * 
     * @type {SystemConfigThumbnailDto}
     * @memberof SystemConfigDto
     */
    'thumbnail': SystemConfigThumbnailDto;
    /**
     * 
     * @type {SystemConfigTrashDto}
     * @memberof SystemConfigDto
     */
    'trash': SystemConfigTrashDto;
}
/**
 * 
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     * 
     * @type {TranscodeHWAccel}
     * @memberof SystemConfigFFmpegDto
     */
    'accel': TranscodeHWAccel;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'bframes': number;
    /**
     * 
     * @type {CQMode}
     * @memberof SystemConfigFFmpegDto
     */
    'cqMode': CQMode;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'crf': number;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'gopSize': number;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'maxBitrate': string;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'npl': number;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'preset': string;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'refs': number;
    /**
     * 
     * @type {AudioCodec}
     * @memberof SystemConfigFFmpegDto
     */
    'targetAudioCodec': AudioCodec;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetResolution': string;
    /**
     * 
     * @type {VideoCodec}
     * @memberof SystemConfigFFmpegDto
     */
    'targetVideoCodec': VideoCodec;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    'temporalAQ': boolean;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'threads': number;
    /**
     * 
     * @type {ToneMapping}
     * @memberof SystemConfigFFmpegDto
     */
    'tonemap': ToneMapping;
    /**
     * 
     * @type {TranscodePolicy}
     * @memberof SystemConfigFFmpegDto
     */
    'transcode': TranscodePolicy;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    'twoPass': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigJobDto
 */
export interface SystemConfigJobDto {
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'backgroundTask': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'clipEncoding': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'library': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'metadataExtraction': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'migration': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'objectTagging': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'recognizeFaces': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'search': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'sidecar': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'storageTemplateMigration': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'thumbnailGeneration': JobSettingsDto;
    /**
     * 
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'videoConversion': JobSettingsDto;
}
/**
 * 
 * @export
 * @interface SystemConfigMachineLearningDto
 */
export interface SystemConfigMachineLearningDto {
    /**
     * 
     * @type {ClassificationConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'classification': ClassificationConfig;
    /**
     * 
     * @type {CLIPConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'clip': CLIPConfig;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigMachineLearningDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {RecognitionConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'facialRecognition': RecognitionConfig;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigMachineLearningDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SystemConfigMapDto
 */
export interface SystemConfigMapDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigMapDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigMapDto
     */
    'tileUrl': string;
}
/**
 * 
 * @export
 * @interface SystemConfigOAuthDto
 */
export interface SystemConfigOAuthDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoLaunch': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoRegister': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'buttonText': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'issuerUrl': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'mobileOverrideEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'mobileRedirectUri': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'storageLabelClaim': string;
}
/**
 * 
 * @export
 * @interface SystemConfigPasswordLoginDto
 */
export interface SystemConfigPasswordLoginDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigPasswordLoginDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigReverseGeocodingDto
 */
export interface SystemConfigReverseGeocodingDto {
    /**
     * 
     * @type {CitiesFile}
     * @memberof SystemConfigReverseGeocodingDto
     */
    'citiesFileOverride': CitiesFile;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigReverseGeocodingDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigStorageTemplateDto
 */
export interface SystemConfigStorageTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigStorageTemplateDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface SystemConfigTemplateStorageOptionDto
 */
export interface SystemConfigTemplateStorageOptionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'dayOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'hourOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'minuteOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'monthOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'presetOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'secondOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'weekOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'yearOptions': Array<string>;
}
/**
 * 
 * @export
 * @interface SystemConfigThumbnailDto
 */
export interface SystemConfigThumbnailDto {
    /**
     * 
     * @type {Colorspace}
     * @memberof SystemConfigThumbnailDto
     */
    'colorspace': Colorspace;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'jpegSize': number;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'quality': number;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'webpSize': number;
}
/**
 * 
 * @export
 * @interface SystemConfigTrashDto
 */
export interface SystemConfigTrashDto {
    /**
     * 
     * @type {number}
     * @memberof SystemConfigTrashDto
     */
    'days': number;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigTrashDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'name': string;
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof TagResponseDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TagTypeEnum = {
    Object: 'OBJECT',
    Face: 'FACE',
    Custom: 'CUSTOM'
} as const;

export type TagTypeEnum = typeof TagTypeEnum[keyof typeof TagTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
} as const;

export type ThumbnailFormat = typeof ThumbnailFormat[keyof typeof ThumbnailFormat];


/**
 * 
 * @export
 * @interface TimeBucketResponseDto
 */
export interface TimeBucketResponseDto {
    /**
     * 
     * @type {number}
     * @memberof TimeBucketResponseDto
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof TimeBucketResponseDto
     */
    'timeBucket': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeBucketSize = {
    Day: 'DAY',
    Month: 'MONTH'
} as const;

export type TimeBucketSize = typeof TimeBucketSize[keyof typeof TimeBucketSize];


/**
 * 
 * @export
 * @enum {string}
 */

export const ToneMapping = {
    Hable: 'hable',
    Mobius: 'mobius',
    Reinhard: 'reinhard',
    Disabled: 'disabled'
} as const;

export type ToneMapping = typeof ToneMapping[keyof typeof ToneMapping];


/**
 * 
 * @export
 * @enum {string}
 */

export const TranscodeHWAccel = {
    Nvenc: 'nvenc',
    Qsv: 'qsv',
    Vaapi: 'vaapi',
    Disabled: 'disabled'
} as const;

export type TranscodeHWAccel = typeof TranscodeHWAccel[keyof typeof TranscodeHWAccel];


/**
 * 
 * @export
 * @enum {string}
 */

export const TranscodePolicy = {
    All: 'all',
    Optimal: 'optimal',
    Required: 'required',
    Disabled: 'disabled'
} as const;

export type TranscodePolicy = typeof TranscodePolicy[keyof typeof TranscodePolicy];


/**
 * 
 * @export
 * @interface UpdateAlbumDto
 */
export interface UpdateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumThumbnailAssetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetDto
 */
export interface UpdateAssetDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAssetDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isArchived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isFavorite'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateLibraryDto
 */
export interface UpdateLibraryDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateLibraryDto
     */
    'exclusionPatterns'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateLibraryDto
     */
    'importPaths'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateLibraryDto
     */
    'isVisible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateLibraryDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'externalPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'memoriesEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'shouldChangePassword'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'storageLabel'?: string;
}
/**
 * 
 * @export
 * @interface UsageByUserDto
 */
export interface UsageByUserDto {
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'usage': number;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userFirstName': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userLastName': string;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'videos': number;
}
/**
 * 
 * @export
 * @interface UserCountResponseDto
 */
export interface UserCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof UserCountResponseDto
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'externalPath': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'memoriesEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'oauthId': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'storageLabel': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ValidateAccessTokenResponseDto
 */
export interface ValidateAccessTokenResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAccessTokenResponseDto
     */
    'authStatus': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VideoCodec = {
    H264: 'h264',
    Hevc: 'hevc',
    Vp9: 'vp9'
} as const;

export type VideoCodec = typeof VideoCodec[keyof typeof VideoCodec];



/**
 * APIKeyApi - axios parameter creator
 * @export
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (aPIKeyCreateDto: APIKeyCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreateDto' is not null or undefined
            assertParamExists('createKey', 'aPIKeyCreateDto', aPIKeyCreateDto)
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKey', 'id', id)
            // verify required parameter 'aPIKeyUpdateDto' is not null or undefined
            assertParamExists('updateKey', 'aPIKeyUpdateDto', aPIKeyUpdateDto)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(aPIKeyCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(id, aPIKeyUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: any): AxiosPromise<APIKeyCreateResponseDto> {
            return localVarFp.createKey(aPIKeyCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(id: string, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.getKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<Array<APIKeyResponseDto>> {
            return localVarFp.getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.updateKey(id, aPIKeyUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     * 
     * @param {APIKeyCreateDto} aPIKeyCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).createKey(aPIKeyCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public deleteKey(id: string, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).deleteKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKey(id: string, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKeys(options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).updateKey(id, aPIKeyUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (id: string, bulkIdsDto: BulkIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'id', id)
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (id: string, addUsersDto: AddUsersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUsersToAlbum', 'id', id)
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto)
            const localVarPath = `/album/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto: CreateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto)
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlbum', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withoutAssets] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (id: string, withoutAssets?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAlbumInfo', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (withoutAssets !== undefined) {
                localVarQueryParameter['withoutAssets'] = withoutAssets;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared?: boolean, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (id: string, bulkIdsDto: BulkIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'id', id)
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (id: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId)
            const localVarPath = `/album/{id}/user/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (id: string, updateAlbumDto: UpdateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlbumInfo', 'id', id)
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(id: string, bulkIdsDto: BulkIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(id, bulkIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(id, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withoutAssets] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(id: string, withoutAssets?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(id, withoutAssets, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(id: string, bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(id, bulkIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(id: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(id, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlbumApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(id: string, bulkIdsDto: BulkIdsDto, key?: string, options?: any): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.addAssetsToAlbum(id, bulkIdsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.addUsersToAlbum(id, addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(createAlbumDto: CreateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.createAlbum(createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlbum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCount(options?: any): AxiosPromise<AlbumCountResponseDto> {
            return localVarFp.getAlbumCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withoutAssets] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(id: string, withoutAssets?: boolean, key?: string, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.getAlbumInfo(id, withoutAssets, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(shared?: boolean, assetId?: string, options?: any): AxiosPromise<Array<AlbumResponseDto>> {
            return localVarFp.getAllAlbums(shared, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(id: string, bulkIdsDto: BulkIdsDto, options?: any): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.removeAssetFromAlbum(id, bulkIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromAlbum(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.updateAlbumInfo(id, updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {BulkIdsDto} bulkIdsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addAssetsToAlbum(id: string, bulkIdsDto: BulkIdsDto, key?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(id, bulkIdsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AddUsersDto} addUsersDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(id, addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAlbumDto} createAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbum(createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public deleteAlbum(id: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).deleteAlbum(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumCount(options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [withoutAssets] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumInfo(id: string, withoutAssets?: boolean, key?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumInfo(id, withoutAssets, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [shared] 
     * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAllAlbums(shared, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {BulkIdsDto} bulkIdsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeAssetFromAlbum(id: string, bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(id, bulkIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeUserFromAlbum(id: string, userId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateAlbumDto} updateAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(id, updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCheck: async (assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkUploadCheckDto' is not null or undefined
            assertParamExists('bulkUploadCheck', 'assetBulkUploadCheckDto', assetBulkUploadCheckDto)
            const localVarPath = `/asset/bulk-upload-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkUploadCheckDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset: async (checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDuplicateAssetDto' is not null or undefined
            assertParamExists('checkDuplicateAsset', 'checkDuplicateAssetDto', checkDuplicateAssetDto)
            const localVarPath = `/asset/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDuplicateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets: async (checkExistingAssetsDto: CheckExistingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkExistingAssetsDto' is not null or undefined
            assertParamExists('checkExistingAssets', 'checkExistingAssetsDto', checkExistingAssetsDto)
            const localVarPath = `/asset/exist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkExistingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetBulkDeleteDto} assetBulkDeleteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets: async (assetBulkDeleteDto: AssetBulkDeleteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkDeleteDto' is not null or undefined
            assertParamExists('deleteAssets', 'assetBulkDeleteDto', assetBulkDeleteDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkDeleteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive: async (assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('downloadArchive', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/asset/download/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (id: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadFile', 'id', id)
            const localVarPath = `/asset/download/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/trash/empty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [updatedAfter] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, updatedAfter?: string, ifNoneMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (ifNoneMatch != null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (id: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAssetById', 'id', id)
            const localVarPath = `/asset/assetById/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetStats: async (isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (id: string, format?: ThumbnailFormat, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAssetThumbnail', 'id', id)
            const localVarPath = `/asset/thumbnail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} timeBucket 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByTimeBucket: async (size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getByTimeBucket', 'size', size)
            // verify required parameter 'timeBucket' is not null or undefined
            assertParamExists('getByTimeBucket', 'timeBucket', timeBucket)
            const localVarPath = `/asset/time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }

            if (timeBucket !== undefined) {
                localVarQueryParameter['timeBucket'] = timeBucket;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DownloadInfoDto} downloadInfoDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadInfo: async (downloadInfoDto: DownloadInfoDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadInfoDto' is not null or undefined
            assertParamExists('getDownloadInfo', 'downloadInfoDto', downloadInfoDto)
            const localVarPath = `/asset/download/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers: async (isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/map-marker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (fileCreatedAfter !== undefined) {
                localVarQueryParameter['fileCreatedAfter'] = (fileCreatedAfter as any instanceof Date) ?
                    (fileCreatedAfter as any).toISOString() :
                    fileCreatedAfter;
            }

            if (fileCreatedBefore !== undefined) {
                localVarQueryParameter['fileCreatedBefore'] = (fileCreatedBefore as any instanceof Date) ?
                    (fileCreatedBefore as any).toISOString() :
                    fileCreatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} day 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryLane: async (day: number, month: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('getMemoryLane', 'day', day)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getMemoryLane', 'month', month)
            const localVarPath = `/asset/memory-lane`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom: async (count?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBuckets: async (size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getTimeBuckets', 'size', size)
            const localVarPath = `/asset/time-buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportAssetDto} importAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (importAssetDto: ImportAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importAssetDto' is not null or undefined
            assertParamExists('importFile', 'importAssetDto', importAssetDto)
            const localVarPath = `/asset/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreAssets: async (bulkIdsDto: BulkIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('restoreAssets', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/asset/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTrash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/trash/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetJobsDto} assetJobsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAssetJobs: async (assetJobsDto: AssetJobsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetJobsDto' is not null or undefined
            assertParamExists('runAssetJobs', 'assetJobsDto', assetJobsDto)
            const localVarPath = `/asset/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetJobsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset: async (searchAssetDto: SearchAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAssetDto' is not null or undefined
            assertParamExists('searchAsset', 'searchAssetDto', searchAssetDto)
            const localVarPath = `/asset/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serveFile', 'id', id)
            const localVarPath = `/asset/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (id: string, updateAssetDto: UpdateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAsset', 'id', id)
            // verify required parameter 'updateAssetDto' is not null or undefined
            assertParamExists('updateAsset', 'updateAssetDto', updateAssetDto)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetBulkUpdateDto} assetBulkUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssets: async (assetBulkUpdateDto: AssetBulkUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkUpdateDto' is not null or undefined
            assertParamExists('updateAssets', 'assetBulkUpdateDto', assetBulkUpdateDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} [key] 
         * @param {string} [duration] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isExternal] 
         * @param {boolean} [isOffline] 
         * @param {boolean} [isReadOnly] 
         * @param {boolean} [isVisible] 
         * @param {string} [libraryId] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData)
            // verify required parameter 'deviceAssetId' is not null or undefined
            assertParamExists('uploadFile', 'deviceAssetId', deviceAssetId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('uploadFile', 'deviceId', deviceId)
            // verify required parameter 'fileCreatedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileCreatedAt', fileCreatedAt)
            // verify required parameter 'fileModifiedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileModifiedAt', fileModifiedAt)
            // verify required parameter 'isFavorite' is not null or undefined
            assertParamExists('uploadFile', 'isFavorite', isFavorite)
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            if (assetData !== undefined) { 
                localVarFormParams.append('assetData', assetData as any);
            }
    
            if (deviceAssetId !== undefined) { 
                localVarFormParams.append('deviceAssetId', deviceAssetId as any);
            }
    
            if (deviceId !== undefined) { 
                localVarFormParams.append('deviceId', deviceId as any);
            }
    
            if (duration !== undefined) { 
                localVarFormParams.append('duration', duration as any);
            }
    
            if (fileCreatedAt !== undefined) { 
                localVarFormParams.append('fileCreatedAt', fileCreatedAt as any);
            }
    
            if (fileModifiedAt !== undefined) { 
                localVarFormParams.append('fileModifiedAt', fileModifiedAt as any);
            }
    
            if (isArchived !== undefined) { 
                localVarFormParams.append('isArchived', isArchived as any);
            }
    
            if (isExternal !== undefined) { 
                localVarFormParams.append('isExternal', isExternal as any);
            }
    
            if (isFavorite !== undefined) { 
                localVarFormParams.append('isFavorite', isFavorite as any);
            }
    
            if (isOffline !== undefined) { 
                localVarFormParams.append('isOffline', isOffline as any);
            }
    
            if (isReadOnly !== undefined) { 
                localVarFormParams.append('isReadOnly', isReadOnly as any);
            }
    
            if (isVisible !== undefined) { 
                localVarFormParams.append('isVisible', isVisible as any);
            }
    
            if (libraryId !== undefined) { 
                localVarFormParams.append('libraryId', libraryId as any);
            }
    
            if (livePhotoData !== undefined) { 
                localVarFormParams.append('livePhotoData', livePhotoData as any);
            }
    
            if (sidecarData !== undefined) { 
                localVarFormParams.append('sidecarData', sidecarData as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUploadCheck(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetBulkUploadCheckResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUploadCheck(assetBulkUploadCheckDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDuplicateAssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDuplicateAsset(checkDuplicateAssetDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckExistingAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExistingAssets(checkExistingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetBulkDeleteDto} assetBulkDeleteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssets(assetBulkDeleteDto: AssetBulkDeleteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssets(assetBulkDeleteDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArchive(assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArchive(assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(id: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [updatedAfter] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, updatedAfter?: string, ifNoneMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(userId, isFavorite, isArchived, skip, updatedAfter, ifNoneMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(id: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetStats(isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetStats(isArchived, isFavorite, isTrashed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(id: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(id, format, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} timeBucket 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByTimeBucket(size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByTimeBucket(size, timeBucket, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedLocationsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedObjectsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DownloadInfoDto} downloadInfoDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadInfo(downloadInfoDto: DownloadInfoDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadInfo(downloadInfoDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapMarkers(isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MapMarkerResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapMarkers(isArchived, isFavorite, fileCreatedAfter, fileCreatedBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} day 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemoryLane(day: number, month: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemoryLaneResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemoryLane(day, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandom(count?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandom(count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeBuckets(size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeBucketResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeBuckets(size, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportAssetDto} importAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(importAssetDto: ImportAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(importAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreAssets(bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreAssets(bulkIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreTrash(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreTrash(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetJobsDto} assetJobsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runAssetJobs(assetJobsDto: AssetJobsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runAssetJobs(assetJobsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAsset(searchAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(id, isThumb, isWeb, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(id: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(id, updateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetBulkUpdateDto} assetBulkUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssets(assetBulkUpdateDto: AssetBulkUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssets(assetBulkUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} [key] 
         * @param {string} [duration] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isExternal] 
         * @param {boolean} [isOffline] 
         * @param {boolean} [isReadOnly] 
         * @param {boolean} [isVisible] 
         * @param {string} [libraryId] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, key, duration, isArchived, isExternal, isOffline, isReadOnly, isVisible, libraryId, livePhotoData, sidecarData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCheck(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: any): AxiosPromise<AssetBulkUploadCheckResponseDto> {
            return localVarFp.bulkUploadCheck(assetBulkUploadCheckDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: any): AxiosPromise<CheckDuplicateAssetResponseDto> {
            return localVarFp.checkDuplicateAsset(checkDuplicateAssetDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: any): AxiosPromise<CheckExistingAssetsResponseDto> {
            return localVarFp.checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetBulkDeleteDto} assetBulkDeleteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets(assetBulkDeleteDto: AssetBulkDeleteDto, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAssets(assetBulkDeleteDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive(assetIdsDto: AssetIdsDto, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadArchive(assetIdsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: string, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFile(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: any): AxiosPromise<void> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [updatedAfter] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, updatedAfter?: string, ifNoneMatch?: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAllAssets(userId, isFavorite, isArchived, skip, updatedAfter, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(id: string, key?: string, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.getAssetById(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetStats(isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options?: any): AxiosPromise<AssetStatsResponseDto> {
            return localVarFp.getAssetStats(isArchived, isFavorite, isTrashed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(id: string, format?: ThumbnailFormat, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.getAssetThumbnail(id, format, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} timeBucket 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByTimeBucket(size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getByTimeBucket(size, timeBucket, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options?: any): AxiosPromise<Array<CuratedLocationsResponseDto>> {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options?: any): AxiosPromise<Array<CuratedObjectsResponseDto>> {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DownloadInfoDto} downloadInfoDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadInfo(downloadInfoDto: DownloadInfoDto, key?: string, options?: any): AxiosPromise<DownloadResponseDto> {
            return localVarFp.getDownloadInfo(downloadInfoDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers(isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: any): AxiosPromise<Array<MapMarkerResponseDto>> {
            return localVarFp.getMapMarkers(isArchived, isFavorite, fileCreatedAfter, fileCreatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} day 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryLane(day: number, month: number, options?: any): AxiosPromise<Array<MemoryLaneResponseDto>> {
            return localVarFp.getMemoryLane(day, month, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom(count?: number, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getRandom(count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TimeBucketSize} size 
         * @param {string} [userId] 
         * @param {string} [albumId] 
         * @param {string} [personId] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isTrashed] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBuckets(size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: any): AxiosPromise<Array<TimeBucketResponseDto>> {
            return localVarFp.getTimeBuckets(size, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(deviceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getUserAssetsByDeviceId(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportAssetDto} importAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(importAssetDto: ImportAssetDto, options?: any): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.importFile(importAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BulkIdsDto} bulkIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreAssets(bulkIdsDto: BulkIdsDto, options?: any): AxiosPromise<void> {
            return localVarFp.restoreAssets(bulkIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTrash(options?: any): AxiosPromise<void> {
            return localVarFp.restoreTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetJobsDto} assetJobsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAssetJobs(assetJobsDto: AssetJobsDto, options?: any): AxiosPromise<void> {
            return localVarFp.runAssetJobs(assetJobsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset(searchAssetDto: SearchAssetDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.searchAsset(searchAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.serveFile(id, isThumb, isWeb, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: string, updateAssetDto: UpdateAssetDto, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.updateAsset(id, updateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetBulkUpdateDto} assetBulkUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssets(assetBulkUpdateDto: AssetBulkUpdateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateAssets(assetBulkUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} [key] 
         * @param {string} [duration] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isExternal] 
         * @param {boolean} [isOffline] 
         * @param {boolean} [isReadOnly] 
         * @param {boolean} [isVisible] 
         * @param {string} [libraryId] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options?: any): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.uploadFile(assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, key, duration, isArchived, isExternal, isOffline, isReadOnly, isVisible, libraryId, livePhotoData, sidecarData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * Checks if assets exist by checksums
     * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public bulkUploadCheck(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).bulkUploadCheck(assetBulkUploadCheckDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check duplicated asset before uploading - for Web upload used
     * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkDuplicateAsset(checkDuplicateAssetDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetBulkDeleteDto} assetBulkDeleteDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAssets(assetBulkDeleteDto: AssetBulkDeleteDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAssets(assetBulkDeleteDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetIdsDto} assetIdsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadArchive(assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadArchive(assetIdsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFile(id: string, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFile(id, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public emptyTrash(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all AssetEntity belong to the user
     * @param {string} [userId] 
     * @param {boolean} [isFavorite] 
     * @param {boolean} [isArchived] 
     * @param {number} [skip] 
     * @param {string} [updatedAfter] 
     * @param {string} [ifNoneMatch] ETag of data already cached on the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllAssets(userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, updatedAfter?: string, ifNoneMatch?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllAssets(userId, isFavorite, isArchived, skip, updatedAfter, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single asset\'s information
     * @param {string} id 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetById(id: string, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetById(id, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetSearchTerms(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [isArchived] 
     * @param {boolean} [isFavorite] 
     * @param {boolean} [isTrashed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetStats(isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetStats(isArchived, isFavorite, isTrashed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ThumbnailFormat} [format] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetThumbnail(id: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetThumbnail(id, format, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TimeBucketSize} size 
     * @param {string} timeBucket 
     * @param {string} [userId] 
     * @param {string} [albumId] 
     * @param {string} [personId] 
     * @param {boolean} [isArchived] 
     * @param {boolean} [isFavorite] 
     * @param {boolean} [isTrashed] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getByTimeBucket(size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getByTimeBucket(size, timeBucket, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedLocations(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedObjects(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DownloadInfoDto} downloadInfoDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getDownloadInfo(downloadInfoDto: DownloadInfoDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getDownloadInfo(downloadInfoDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [isArchived] 
     * @param {boolean} [isFavorite] 
     * @param {string} [fileCreatedAfter] 
     * @param {string} [fileCreatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getMapMarkers(isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getMapMarkers(isArchived, isFavorite, fileCreatedAfter, fileCreatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} day 
     * @param {number} month 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getMemoryLane(day: number, month: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getMemoryLane(day, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getRandom(count?: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getRandom(count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TimeBucketSize} size 
     * @param {string} [userId] 
     * @param {string} [albumId] 
     * @param {string} [personId] 
     * @param {boolean} [isArchived] 
     * @param {boolean} [isFavorite] 
     * @param {boolean} [isTrashed] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getTimeBuckets(size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getTimeBuckets(size, userId, albumId, personId, isArchived, isFavorite, isTrashed, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportAssetDto} importAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public importFile(importAssetDto: ImportAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).importFile(importAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BulkIdsDto} bulkIdsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public restoreAssets(bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).restoreAssets(bulkIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public restoreTrash(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).restoreTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetJobsDto} assetJobsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public runAssetJobs(assetJobsDto: AssetJobsDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).runAssetJobs(assetJobsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchAssetDto} searchAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).searchAsset(searchAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [isThumb] 
     * @param {boolean} [isWeb] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public serveFile(id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).serveFile(id, isThumb, isWeb, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateAssetDto} updateAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(id: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(id, updateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetBulkUpdateDto} assetBulkUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAssets(assetBulkUpdateDto: AssetBulkUpdateDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAssets(assetBulkUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} assetData 
     * @param {string} deviceAssetId 
     * @param {string} deviceId 
     * @param {string} fileCreatedAt 
     * @param {string} fileModifiedAt 
     * @param {boolean} isFavorite 
     * @param {string} [key] 
     * @param {string} [duration] 
     * @param {boolean} [isArchived] 
     * @param {boolean} [isExternal] 
     * @param {boolean} [isOffline] 
     * @param {boolean} [isReadOnly] 
     * @param {boolean} [isVisible] 
     * @param {string} [libraryId] 
     * @param {File} [livePhotoData] 
     * @param {File} [sidecarData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public uploadFile(assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).uploadFile(assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, key, duration, isArchived, isExternal, isOffline, isReadOnly, isVisible, libraryId, livePhotoData, sidecarData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditApi - axios parameter creator
 * @export
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EntityType} entityType 
         * @param {string} after 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditDeletes: async (entityType: EntityType, after: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getAuditDeletes', 'entityType', entityType)
            // verify required parameter 'after' is not null or undefined
            assertParamExists('getAuditDeletes', 'after', after)
            const localVarPath = `/audit/deletes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 * @export
 */
export const AuditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EntityType} entityType 
         * @param {string} after 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditDeletes(entityType: EntityType, after: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditDeletesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditDeletes(entityType, after, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditApi - factory interface
 * @export
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         * 
         * @param {EntityType} entityType 
         * @param {string} after 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditDeletes(entityType: EntityType, after: string, userId?: string, options?: any): AxiosPromise<AuditDeletesResponseDto> {
            return localVarFp.getAuditDeletes(entityType, after, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditApi - object-oriented interface
 * @export
 * @class AuditApi
 * @extends {BaseAPI}
 */
export class AuditApi extends BaseAPI {
    /**
     * 
     * @param {EntityType} entityType 
     * @param {string} after 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getAuditDeletes(entityType: EntityType, after: string, userId?: string, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).getAuditDeletes(entityType, after, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp: async (signUpDto: SignUpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('adminSignUp', 'signUpDto', signUpDto)
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto: LoginCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logoutAuthDevice', 'id', id)
            const localVarPath = `/auth/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSignupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignUp(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthDeviceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevice(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp(signUpDto: SignUpDto, options?: any): AxiosPromise<AdminSignupResponseDto> {
            return localVarFp.adminSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices(options?: any): AxiosPromise<Array<AuthDeviceResponseDto>> {
            return localVarFp.getAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginCredentialDto: LoginCredentialDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.logoutAuthDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices(options?: any): AxiosPromise<void> {
            return localVarFp.logoutAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options?: any): AxiosPromise<ValidateAccessTokenResponseDto> {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).adminSignUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginCredentialDto} loginCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevice(id: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateAccessToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobName} id 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand: async (id: JobName, jobCommandDto: JobCommandDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendJobCommand', 'id', id)
            // verify required parameter 'jobCommandDto' is not null or undefined
            assertParamExists('sendJobCommand', 'jobCommandDto', jobCommandDto)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobsStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllJobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobsStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {JobName} id 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJobCommand(id: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJobCommand(id, jobCommandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus(options?: any): AxiosPromise<AllJobStatusResponseDto> {
            return localVarFp.getAllJobsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JobName} id 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand(id: JobName, jobCommandDto: JobCommandDto, options?: any): AxiosPromise<JobStatusDto> {
            return localVarFp.sendJobCommand(id, jobCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getAllJobsStatus(options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getAllJobsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JobName} id 
     * @param {JobCommandDto} jobCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public sendJobCommand(id: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).sendJobCommand(id, jobCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateLibraryDto} createLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibrary: async (createLibraryDto: CreateLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLibraryDto' is not null or undefined
            assertParamExists('createLibrary', 'createLibraryDto', createLibraryDto)
            const localVarPath = `/library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibrary: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLibrary', 'id', id)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllForUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryInfo: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLibraryInfo', 'id', id)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryStatistics: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLibraryStatistics', 'id', id)
            const localVarPath = `/library/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOfflineFiles: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeOfflineFiles', 'id', id)
            const localVarPath = `/library/{id}/removeOffline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ScanLibraryDto} scanLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanLibrary: async (id: string, scanLibraryDto: ScanLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scanLibrary', 'id', id)
            // verify required parameter 'scanLibraryDto' is not null or undefined
            assertParamExists('scanLibrary', 'scanLibraryDto', scanLibraryDto)
            const localVarPath = `/library/{id}/scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scanLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateLibraryDto} updateLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibrary: async (id: string, updateLibraryDto: UpdateLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLibrary', 'id', id)
            // verify required parameter 'updateLibraryDto' is not null or undefined
            assertParamExists('updateLibrary', 'updateLibraryDto', updateLibraryDto)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateLibraryDto} createLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLibrary(createLibraryDto: CreateLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLibrary(createLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLibrary(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLibrary(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllForUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LibraryResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllForUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryInfo(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryInfo(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryStatistics(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryStatistics(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOfflineFiles(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOfflineFiles(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {ScanLibraryDto} scanLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanLibrary(id: string, scanLibraryDto: ScanLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanLibrary(id, scanLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateLibraryDto} updateLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibrary(id: string, updateLibraryDto: UpdateLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLibrary(id, updateLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateLibraryDto} createLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibrary(createLibraryDto: CreateLibraryDto, options?: any): AxiosPromise<LibraryResponseDto> {
            return localVarFp.createLibrary(createLibraryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibrary(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLibrary(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllForUser(options?: any): AxiosPromise<Array<LibraryResponseDto>> {
            return localVarFp.getAllForUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryInfo(id: string, options?: any): AxiosPromise<LibraryResponseDto> {
            return localVarFp.getLibraryInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryStatistics(id: string, options?: any): AxiosPromise<LibraryStatsResponseDto> {
            return localVarFp.getLibraryStatistics(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOfflineFiles(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOfflineFiles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ScanLibraryDto} scanLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanLibrary(id: string, scanLibraryDto: ScanLibraryDto, options?: any): AxiosPromise<void> {
            return localVarFp.scanLibrary(id, scanLibraryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateLibraryDto} updateLibraryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibrary(id: string, updateLibraryDto: UpdateLibraryDto, options?: any): AxiosPromise<LibraryResponseDto> {
            return localVarFp.updateLibrary(id, updateLibraryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * 
     * @param {CreateLibraryDto} createLibraryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public createLibrary(createLibraryDto: CreateLibraryDto, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).createLibrary(createLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteLibrary(id: string, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).deleteLibrary(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getAllForUser(options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getAllForUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryInfo(id: string, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryStatistics(id: string, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryStatistics(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public removeOfflineFiles(id: string, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).removeOfflineFiles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ScanLibraryDto} scanLibraryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public scanLibrary(id: string, scanLibraryDto: ScanLibraryDto, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).scanLibrary(id, scanLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateLibraryDto} updateLibraryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public updateLibrary(id: string, updateLibraryDto: UpdateLibraryDto, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).updateLibrary(id, updateLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeOAuth: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('authorizeOAuth', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('callback', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        generateConfig: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('generateConfig', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('link', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/mobile-redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeOAuth(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthAuthorizeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeOAuth(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateConfig(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async link(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.link(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileRedirect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileRedirect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeOAuth(oAuthConfigDto: OAuthConfigDto, options?: any): AxiosPromise<OAuthAuthorizeResponseDto> {
            return localVarFp.authorizeOAuth(oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.callback(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        generateConfig(oAuthConfigDto: OAuthConfigDto, options?: any): AxiosPromise<OAuthConfigResponseDto> {
            return localVarFp.generateConfig(oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.link(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect(options?: any): AxiosPromise<void> {
            return localVarFp.mobileRedirect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.unlink(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * 
     * @param {OAuthConfigDto} oAuthConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public authorizeOAuth(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).authorizeOAuth(oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthCallbackDto} oAuthCallbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).callback(oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * @deprecated use feature flags and /oauth/authorize
     * @param {OAuthConfigDto} oAuthConfigDto 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).generateConfig(oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthCallbackDto} oAuthCallbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public link(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).link(oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public mobileRedirect(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).mobileRedirect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public unlink(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).unlink(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners: async (direction: 'shared-by' | 'shared-with', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getPartners', 'direction', direction)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removePartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartners(direction: 'shared-by' | 'shared-with', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartners(direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner(id: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createPartner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners(direction: 'shared-by' | 'shared-with', options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getPartners(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removePartner(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public createPartner(id: string, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).createPartner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'shared-by' | 'shared-with'} direction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartners(direction: 'shared-by' | 'shared-with', options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).getPartners(direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public removePartner(id: string, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).removePartner(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [withHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople: async (withHidden?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (withHidden !== undefined) {
                localVarQueryParameter['withHidden'] = withHidden;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonAssets', 'id', id)
            const localVarPath = `/person/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonThumbnail', 'id', id)
            const localVarPath = `/person/{id}/thumbnail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {MergePersonDto} mergePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePerson: async (id: string, mergePersonDto: MergePersonDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergePerson', 'id', id)
            // verify required parameter 'mergePersonDto' is not null or undefined
            assertParamExists('mergePerson', 'mergePersonDto', mergePersonDto)
            const localVarPath = `/person/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergePersonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PeopleUpdateDto} peopleUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePeople: async (peopleUpdateDto: PeopleUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peopleUpdateDto' is not null or undefined
            assertParamExists('updatePeople', 'peopleUpdateDto', peopleUpdateDto)
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(peopleUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, personUpdateDto: PersonUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            // verify required parameter 'personUpdateDto' is not null or undefined
            assertParamExists('updatePerson', 'personUpdateDto', personUpdateDto)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {boolean} [withHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPeople(withHidden?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeopleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPeople(withHidden, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonAssets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonAssets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonThumbnail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonThumbnail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {MergePersonDto} mergePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergePerson(id: string, mergePersonDto: MergePersonDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergePerson(id, mergePersonDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PeopleUpdateDto} peopleUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePeople(peopleUpdateDto: PeopleUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePeople(peopleUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, personUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         * 
         * @param {boolean} [withHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople(withHidden?: boolean, options?: any): AxiosPromise<PeopleResponseDto> {
            return localVarFp.getAllPeople(withHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: string, options?: any): AxiosPromise<PersonResponseDto> {
            return localVarFp.getPerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets(id: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getPersonAssets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.getPersonThumbnail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {MergePersonDto} mergePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePerson(id: string, mergePersonDto: MergePersonDto, options?: any): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.mergePerson(id, mergePersonDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PeopleUpdateDto} peopleUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePeople(peopleUpdateDto: PeopleUpdateDto, options?: any): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.updatePeople(peopleUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: any): AxiosPromise<PersonResponseDto> {
            return localVarFp.updatePerson(id, personUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     * 
     * @param {boolean} [withHidden] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getAllPeople(withHidden?: boolean, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getAllPeople(withHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPerson(id: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonAssets(id: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonAssets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonThumbnail(id: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonThumbnail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {MergePersonDto} mergePersonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public mergePerson(id: string, mergePersonDto: MergePersonDto, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).mergePerson(id, mergePersonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PeopleUpdateDto} peopleUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePeople(peopleUpdateDto: PeopleUpdateDto, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePeople(peopleUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PersonUpdateDto} personUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePerson(id, personUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {string} [exifInfoProjectionType] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, exifInfoProjectionType?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (clip !== undefined) {
                localVarQueryParameter['clip'] = clip;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (exifInfoCity !== undefined) {
                localVarQueryParameter['exifInfo.city'] = exifInfoCity;
            }

            if (exifInfoState !== undefined) {
                localVarQueryParameter['exifInfo.state'] = exifInfoState;
            }

            if (exifInfoCountry !== undefined) {
                localVarQueryParameter['exifInfo.country'] = exifInfoCountry;
            }

            if (exifInfoMake !== undefined) {
                localVarQueryParameter['exifInfo.make'] = exifInfoMake;
            }

            if (exifInfoModel !== undefined) {
                localVarQueryParameter['exifInfo.model'] = exifInfoModel;
            }

            if (exifInfoProjectionType !== undefined) {
                localVarQueryParameter['exifInfo.projectionType'] = exifInfoProjectionType;
            }

            if (smartInfoObjects) {
                localVarQueryParameter['smartInfo.objects'] = smartInfoObjects;
            }

            if (smartInfoTags) {
                localVarQueryParameter['smartInfo.tags'] = smartInfoTags;
            }

            if (recent !== undefined) {
                localVarQueryParameter['recent'] = recent;
            }

            if (motion !== undefined) {
                localVarQueryParameter['motion'] = motion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPerson: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchPerson', 'name', name)
            const localVarPath = `/search/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExploreData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchExploreResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExploreData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {string} [exifInfoProjectionType] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, exifInfoProjectionType?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, query, clip, type, isFavorite, isArchived, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, exifInfoProjectionType, smartInfoObjects, smartInfoTags, recent, motion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPerson(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPerson(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData(options?: any): AxiosPromise<Array<SearchExploreResponseDto>> {
            return localVarFp.getExploreData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {string} [exifInfoProjectionType] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, exifInfoProjectionType?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: any): AxiosPromise<SearchResponseDto> {
            return localVarFp.search(q, query, clip, type, isFavorite, isArchived, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, exifInfoProjectionType, smartInfoObjects, smartInfoTags, recent, motion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPerson(name: string, options?: any): AxiosPromise<Array<PersonResponseDto>> {
            return localVarFp.searchPerson(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getExploreData(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getExploreData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 
     * @param {string} [query] 
     * @param {boolean} [clip] 
     * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
     * @param {boolean} [isFavorite] 
     * @param {boolean} [isArchived] 
     * @param {string} [exifInfoCity] 
     * @param {string} [exifInfoState] 
     * @param {string} [exifInfoCountry] 
     * @param {string} [exifInfoMake] 
     * @param {string} [exifInfoModel] 
     * @param {string} [exifInfoProjectionType] 
     * @param {Array<string>} [smartInfoObjects] 
     * @param {Array<string>} [smartInfoTags] 
     * @param {boolean} [recent] 
     * @param {boolean} [motion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, exifInfoProjectionType?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(q, query, clip, type, isFavorite, isArchived, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, exifInfoProjectionType, smartInfoObjects, smartInfoTags, recent, motion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPerson(name: string, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPerson(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedMediaTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/media-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerFeaturesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedMediaTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerMediaTypesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedMediaTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig(options?: any): AxiosPromise<ServerConfigDto> {
            return localVarFp.getServerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerFeatures(options?: any): AxiosPromise<ServerFeaturesDto> {
            return localVarFp.getServerFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfoResponseDto> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options?: any): AxiosPromise<ServerVersionResponseDto> {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<ServerStatsResponseDto> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedMediaTypes(options?: any): AxiosPromise<ServerMediaTypesResponseDto> {
            return localVarFp.getSupportedMediaTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): AxiosPromise<ServerPingResponse> {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerConfig(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerFeatures(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerVersion(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getSupportedMediaTypes(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getSupportedMediaTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public pingServer(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharedLinkApi - axios parameter creator
 * @export
 */
export const SharedLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedLinkAssets: async (id: string, assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSharedLinkAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('addSharedLinkAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/shared-link/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SharedLinkCreateDto} sharedLinkCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedLink: async (sharedLinkCreateDto: SharedLinkCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sharedLinkCreateDto' is not null or undefined
            assertParamExists('createSharedLink', 'sharedLinkCreateDto', sharedLinkCreateDto)
            const localVarPath = `/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedLinkCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shared-link/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSharedLinkById', 'id', id)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLink', 'id', id)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLinkAssets: async (id: string, assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLinkAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('removeSharedLinkAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/shared-link/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SharedLinkEditDto} sharedLinkEditDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedLink: async (id: string, sharedLinkEditDto: SharedLinkEditDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSharedLink', 'id', id)
            // verify required parameter 'sharedLinkEditDto' is not null or undefined
            assertParamExists('updateSharedLink', 'sharedLinkEditDto', sharedLinkEditDto)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedLinkEditDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedLinkApi - functional programming interface
 * @export
 */
export const SharedLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSharedLinkAssets(id, assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SharedLinkCreateDto} sharedLinkCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSharedLink(sharedLinkCreateDto: SharedLinkCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSharedLink(sharedLinkCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedLinks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedLinkResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedLinks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySharedLink(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySharedLink(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedLinkById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedLinkById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLinkAssets(id, assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {SharedLinkEditDto} sharedLinkEditDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSharedLink(id: string, sharedLinkEditDto: SharedLinkEditDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSharedLink(id, sharedLinkEditDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharedLinkApi - factory interface
 * @export
 */
export const SharedLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedLinkApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: any): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.addSharedLinkAssets(id, assetIdsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SharedLinkCreateDto} sharedLinkCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedLink(sharedLinkCreateDto: SharedLinkCreateDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createSharedLink(sharedLinkCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks(options?: any): AxiosPromise<Array<SharedLinkResponseDto>> {
            return localVarFp.getAllSharedLinks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink(key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getMySharedLink(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById(id: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getSharedLinkById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSharedLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: any): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.removeSharedLinkAssets(id, assetIdsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SharedLinkEditDto} sharedLinkEditDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedLink(id: string, sharedLinkEditDto: SharedLinkEditDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.updateSharedLink(id, sharedLinkEditDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedLinkApi - object-oriented interface
 * @export
 * @class SharedLinkApi
 * @extends {BaseAPI}
 */
export class SharedLinkApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AssetIdsDto} assetIdsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public addSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).addSharedLinkAssets(id, assetIdsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SharedLinkCreateDto} sharedLinkCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public createSharedLink(sharedLinkCreateDto: SharedLinkCreateDto, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).createSharedLink(sharedLinkCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getAllSharedLinks(options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getAllSharedLinks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getMySharedLink(key?: string, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getMySharedLink(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getSharedLinkById(id: string, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getSharedLinkById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public removeSharedLink(id: string, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).removeSharedLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AssetIdsDto} assetIdsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public removeSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).removeSharedLinkAssets(id, assetIdsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SharedLinkEditDto} sharedLinkEditDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public updateSharedLink(id: string, sharedLinkEditDto: SharedLinkEditDto, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).updateSharedLink(id, sharedLinkEditDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemConfigApi - axios parameter creator
 * @export
 */
export const SystemConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/storage-template-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig: async (systemConfigDto: SystemConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemConfigDto' is not null or undefined
            assertParamExists('updateConfig', 'systemConfigDto', systemConfigDto)
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigApi - functional programming interface
 * @export
 */
export const SystemConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaults(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageTemplateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigTemplateStorageOptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageTemplateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfig(systemConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemConfigApi - factory interface
 * @export
 */
export const SystemConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getDefaults(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions(options?: any): AxiosPromise<SystemConfigTemplateStorageOptionDto> {
            return localVarFp.getStorageTemplateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig(systemConfigDto: SystemConfigDto, options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.updateConfig(systemConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemConfigApi - object-oriented interface
 * @export
 * @class SystemConfigApi
 * @extends {BaseAPI}
 */
export class SystemConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getDefaults(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getDefaults(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getStorageTemplateOptions(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getStorageTemplateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SystemConfigDto} systemConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).updateConfig(systemConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagDto: CreateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('createTag', 'createTagDto', createTagDto)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTag', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAssets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTagAssets', 'id', id)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTagById', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAssets: async (id: string, assetIdsDto: AssetIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('tagAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagAssets: async (id: string, assetIdsDto: AssetIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('untagAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('untagAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (id: string, updateTagDto: UpdateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTag', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('updateTag', 'updateTagDto', updateTagDto)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagDto: CreateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagAssets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagAssets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagAssets(id, assetIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagAssets(id, assetIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(id, updateTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(createTagDto: CreateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.createTag(createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(options?: any): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.getAllTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAssets(id: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getTagAssets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById(id: string, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.getTagById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAssets(id: string, assetIdsDto: AssetIdsDto, options?: any): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.tagAssets(id, assetIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AssetIdsDto} assetIdsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagAssets(id: string, assetIdsDto: AssetIdsDto, options?: any): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.untagAssets(id, assetIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: string, updateTagDto: UpdateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.updateTag(id, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public createTag(createTagDto: CreateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).createTag(createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public deleteTag(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).deleteTag(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getAllTags(options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getAllTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagAssets(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagAssets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagById(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AssetIdsDto} assetIdsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).tagAssets(id, assetIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AssetIdsDto} assetIdsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public untagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).untagAssets(id, assetIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public updateTag(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).updateTag(id, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file)
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProfileImage', 'id', id)
            const localVarPath = `/user/profile-image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/user/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreUser', 'id', id)
            const localVarPath = `/user/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCount(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(file: File, options?: any): AxiosPromise<CreateProfileImageResponseDto> {
            return localVarFp.createProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(isAll: boolean, options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getAllUsers(isAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProfileImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount(admin?: boolean, options?: any): AxiosPromise<UserCountResponseDto> {
            return localVarFp.getUserCount(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(id: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.restoreUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfileImage(file: File, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} isAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(isAll: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(isAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfileImage(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getProfileImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserCount(admin?: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserCount(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public restoreUser(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).restoreUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


